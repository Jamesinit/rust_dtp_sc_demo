# BCT 测试用脚本

## 使用方法

`python main.py`会直接调用当前目录中的`config.json`作为配置文件进行实验测试。`main.py`接受一个参数，提供`config.json`文件的位置，例如`python main.py ./something/config.json`

`config.json`的格式可以参考如下说明：

```json
[
    {
        "block_size": 50, // 一个块中有多少个数据包的大小，一个数据包默认 1350B 。这个数值最大为 740
        "block_num": 10,  // 块的总体个数 int
        "redundancy": 0.0,  // 冗余程度 float: [0, inf)
        "cc": ["bbr"], // 拥塞控制算法，有 "bbr", "cubic", "reno" 三个选项。如果数组为空则认为三个都要测试。
        "bw": 100, // Mbps TC 工具的网络限速
        "rtt": 50, // ms
        "loss": 0 // float: [0, 1] 这个字段暂时不会产生效果
    }
    {
        ... // 可以有多个配置
    }
]
```

## 实验结果

实验结果储存于`results`目录下，由 t 开头的目录代表实验开始的时间，其中包括本次实验所使用的`config.json`和若干测试结果，格式为`index_cc`，即该配置在配置文件数组中的下标和当前测试使用的拥塞控制算法。

每个实验结果类似如下：

```text
{"block_size": 50, "block_num": 10, "redundancy": 0.0, "cc": "bbr", "bw": 100, "rtt": 50, "loss": 0}
{"bct(ms)": "146"}
{"bct(ms)": "231"}
{"bct(ms)": "303"}
{"bct(ms)": "394"}
{"bct(ms)": "468"}
{"bct(ms)": "540"}
{"bct(ms)": "602"}
```

第一行代表本次运行的配置，其中`cc`字段变成了单个字符串而不是数组。其余的每一行是结束的数据块按结束时间顺序打印 bct 。

## 运行原理

### 镜像与拥塞控制算法

脚本认为每一个拥塞控制算法对应了一个全新的镜像，镜像名默认为 `simonkorl0228/test_image:yg.{}`，其中括号中的内容即为配置中的拥塞控制算法名

### 运行次数

配置中的 `block_num` 代表了一次运行中需要传输块的个数，每一个配置(config)代表了一次运行。在每两次运行中需要重新启动一次 docker 容器。

### 运行过程

1. 读取配置文件中的数据并解析
2. 创建一次实验对应的储存目录
3. 对于每一个配置(config)执行以下工作
  1. 创建该配置所对应的测试块文件
  2. 创建该配置对应的网络配置文件
  3. 对每一个需要测试的拥塞控制算法执行以下操作
    1. 启动镜像对应的容器
    2. 向容器中拷贝若干文件，这包括 trace 数据以及部分运行脚本以及库文件
    3. 运行测试。这会启动 s/c 端并且将得到的结果复制到 logs 目录下
    4. 从 logs 目录下得到的结果中解析 client 端的数据，并且将 BCT 数据保存到目标路径下
    5. 保存本次测试的配置信息，并且写入文件

